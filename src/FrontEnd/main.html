<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI TOWN</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600&display=swap" rel="stylesheet">
    <style>
        /* Global Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #f0f0f0;
            background-image: url('background.jpg');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            position: relative;
        }

        .rectangle-container {
            display: flex;
            justify-content: center;
            align-items: center;
            background-size: cover;
            background-position: center;
            border-radius: 50px;
            color: white;
            font-size: 3rem;
            font-weight: 600;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.7);
            width: 470px;
            height: 110px;
            padding: 4px 0px;
            margin-top: 20px;
            position: relative; /* Make it relative for positioning the sidebar */
        }

        .rectangle-container h1 {
            color: #2C4F6B;
            margin: 0;
        }

        .login-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            font-size: 1.2rem;
            background-color: #2C4F6B;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease;
        }

        .login-btn:hover {
            background-color: #1f3a55;
        }

        .chat-container {
            display: none; /* Initially hidden */
            position: fixed;
            bottom: 20px;
            right: 12px; /* Adjusted to move the chatbox approximately 1cm to the left */
            width: 300px;
            height: 500px; /* Increased height for a longer chatbox */
            background-color: #fff8e1; /* Light sand color */
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            padding: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column; /* Flex direction for vertical layout */
        }

        .close-chat-btn {
            background-color: transparent;
            border: none;
            color: #2C4F6B;
            font-size: 1.2rem;
            cursor: pointer;
            position: absolute;
            top: 5px;
            right: 10px;
        }

        #chatHeader {
            font-weight: bold; /* Make the header bold */
            margin-bottom: 10px; /* Add some space below the header */
        }

        #chatOutput {
            flex: 1; /* Allow this to take up available space */
            max-height: 400px; /* Adjusted for more space */
            overflow-y: auto; /* Enable scrolling */
            margin-bottom: 10px;
            padding: 5px; /* Padding for better spacing */
        }

        .message {
            margin: 5px 0; /* Space between messages */
            padding: 5px;
            border-radius: 5px;
        }

        .user-message {
            background-color: #d1e7dd; /* Light greenish background for user messages */
            border-left: 5px solid #0f5132; /* Darker green border */
        }

        .character-message {
            background-color: #ffeeba; /* Light yellow background for character messages */
            border-left: 5px solid #856404; /* Darker yellow border */
        }

        .separator {
            height: 1px;
            background-color: #e2b005; /* Sand color for the separator */
            margin: 5px 0; /* Space around the separator */
        }

        #chatInput {
            width: calc(100% - 90px);
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-right: 5px; /* Space between input and button */
        }

        #sendChatButton {
            padding: 10px 15px;
            background-color: #2C4F6B;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            height: 100%; /* Match the height of the input */
        }

        #sendChatButton:hover {
            background-color: #1f3a55;
        }
        
        .highlight {
            border: 2px solid yellow; /* Change color and thickness as needed */
            border-radius: 5px; /* Optional: add rounded corners */
            position: relative; /* Needed for positioning */
            z-index: 10; /* Ensure it appears above other elements */
        }

        .table-container {
            margin-top: 40px;
            width: 900px;
            height: 450px;
            overflow: hidden; /* Hide the scrollbars */
            border: 5px solid #2C4F6B;
            border-radius: 15px;
            position: relative;
            cursor: grab; /* Show grabbing cursor */
            background-image: url('event_background.png');
            background-size: cover; /* Cover the entire table */
            background-position: center; /* Center the background */
        }

        table {
            width: 1500px; /* Larger than the container width for scrolling */
            height: 900px; /* Larger than the container height for scrolling */
            border-collapse: collapse;
        }

        td {
            width: 30px; /* Set the width of each cell */
            height: 30px; /* Set the height of each cell */
            background-image: url('floor1.jpg'); /* Use your image for the floor */
            background-size: cover;
            background-position: center;
            position: relative; /* Ensure the character is positioned correctly inside the cell */
        }

        .character {
            width: 100%;       /* Fill the entire width of the cell */
            height: 100%;      /* Fill the entire height of the cell */
            object-fit: cover; /* Ensure the image covers the cell without distortion */
            position: absolute; /* Position the character absolutely within the cell */
            top: 0;            /* Ensure it starts from the top of the cell */
            left: 0;           /* Ensure it starts from the left of the cell */
            z-index: 1;        /* Ensure the character stays above the floor background */
            transition: transform 0.5s ease; /* Smooth transition for movement */
            cursor: pointer;   /* Change cursor to pointer for the character */
        }

        #joinEventButton {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #2C4F6B; /* Button background color */
            color: white; /* Text color */
            border: none; /* No border */
            border-radius: 25px; /* Rounded corners */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Shadow effect */
            transition: background-color 0.3s ease; /* Transition for hover effect */
        }

        #joinEventButton:hover {
            background-color: #1f3a55; /* Darker shade on hover */
        }

        /* Sidebar styles for environmental elements */
        .sidebar {
            position: absolute; /* Change to absolute positioning */
            top: 155px; /* Move up 19 pixels from 174px */
            left: -209px; /* Move left 38 pixels from -171px */
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: rgba(255, 255, 255, 0.8); /* Semi-transparent background */
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 10; /* Ensure the sidebar is above other elements */
        }

        .sidebar img {
            width: 40px; /* Size of the icons */
            height: 40px; /* Size of the icons */
            margin: 5px 0; /* Space between icons */
            cursor: pointer;
            transition: transform 0.2s;
        }

        .sidebar img:hover {
            transform: scale(1.1); /* Slightly enlarge on hover */
        }

        /* Prevent images from being selected */
        img {
            user-select: none; /* Prevent text selection */
            -webkit-user-drag: none; /* Prevent dragging in WebKit browsers */
            -moz-user-select: none; /* Prevent text selection in Firefox */
        }

        /* Style for the 3x2 environmental element */
        .large-element {
            position: absolute; /* Position absolutely within the table container */
            width: 90px; /* 3 cells wide (3 * 30px) */
            height: 60px; /* 2 cells tall (2 * 30px) */
            object-fit: cover; /* Ensure the image covers the area without distortion */
            z-index: 5; /* Ensure it's above the table */
        }

        /* Style for the 2x2 environmental elements */
        .small-element {
            position: absolute; /* Position absolutely within the table container */
            width: 60px; /* 2 cells wide (2 * 30px) */
            height: 60px; /* 2 cells tall (2 * 30px) */
            object-fit: cover; /* Ensure the image covers the area without distortion */
            z-index: 5; /* Ensure it's above the table */
        }
    </style>
</head>
<body>

    <!-- Login Button -->
    <a href="login.html"><button class="login-btn">Login</button></a>

    <!-- Rectangle Container -->
    <div class="rectangle-container">
        <h1>AI TOWN</h1>

        <!-- Sidebar for Environmental Elements -->
        <div class="sidebar">
            <img src="map_add_1.png" id="treeIcon" alt="Tree" title="Tree" />
            <img src="map_add_2.png" id="lakeIcon" alt="Lake" title="Lake" />
            <img src="map_add_3.png" id="houseIcon" alt="house" title="house" /> <!-- New icon added -->
        </div>
    </div>

    <!-- Chat Container -->
    <div class="chat-container" id="chatContainer" style="display: none;"> <!-- Ensure it's hidden initially -->
        <button class="close-chat-btn" id="closeChatButton">&times;</button>
        <div id="chatHeader"></div> <!-- Added header for name and role -->
        <div id="chatOutput"></div>
        <div style="display: flex; margin-top: auto;"> <!-- Flexbox to keep input at the bottom -->
            <input type="text" id="chatInput" placeholder="Type your message..." />
            <button id="sendChatButton">Send</button>
        </div>
    </div>

    <!-- Table Container -->
    <div class="table-container" id="tableContainer">
        <table>
            <tbody>
                <script>
                    // Create the 30x50 table
                    for (let i = 0; i < 30; i++) {
                        document.write('<tr>');
                        for (let j = 0; j < 50; j++) {
                            document.write('<td class="empty"></td>');
                        }
                        document.write('</tr>');
                    }
                </script>
            </tbody>
        </table>
    </div>
    <button id="joinEventButton">Join event</button>

    <script>
        let isMoving = true; // Flag to control character movement
        let timer; // Variable to hold the timer interval
        let countdown = 60; // Countdown time in seconds
        let isDraggingEnabled = true;
        const characters = []; // Array to hold character objects
        const environmentalElements = []; // Array to hold environmental elements
        const numOfHeroes = 10; // Number of heroes
        const table = document.querySelector('table');
        const tableContainer = document.getElementById('tableContainer');
        const moveturn = [
            '1', '2', '3',
            '2', '1', '2',
            '3', '2', '1'
        ];

        // Name lists
        const maleNames = [
            "Michael", "Robert", "John", "David", "William",
            "Richard", "Joseph", "Thomas", "Christopher", "Charles",
            "Daniel", "Matthew", "Anthony", "Mark", "Donald",
            "Steven", "Andrew", "Paul", "Joshua"
        ];
        
        const femaleNames = [
            "Patricia", "Jennifer", "Linda", "Elizabeth", "Barbara",
            "Susan", "Jessica", "Karen", "Sarah", "Lisa",
            "Nancy", "Sandra", "Betty", "Ashley", "Emily",
            "Kimberly", "Margaret", "Donna", "Michelle"
        ];

        // Function to get a random name from a list and remove it from the list
        function getRandomName(nameList) {
            const randomIndex = Math.floor(Math.random() * nameList.length);
            return nameList.splice(randomIndex, 1)[0]; // Remove and return the name
        }

        // Function to create a character object (modified to include "You")
        function createCharacter(heroType, initialRow, initialCol, isPlayerCharacter = false) {
            let name, role;

            // Assign name and role based on hero type
            if (isPlayerCharacter) {
                name = "You"; // Label as "You"
                role = "Player"; // You can set a specific role for the player if needed
            } else {
                if (heroType === 1) {
                    name = getRandomName(femaleNames);
                    role = "Student";
                } else if (heroType === 2) {
                    name = getRandomName(femaleNames);
                    role = "Teacher";
                } else if (heroType === 3) {
                    name = getRandomName(femaleNames);
                    role = "Artist";
                } else if (heroType === 4) {
                    name = getRandomName(femaleNames);
                    role = "Shopkeeper";
                } else if (heroType === 5) {
                    name = getRandomName(maleNames);
                    role = "Barber";
                } else if (heroType === 6) {
                    name = getRandomName(maleNames);
                    role = "Farmer";
                }
            }

            return {
                type: heroType,
                position: { row: initialRow, col: initialCol },
                element: null, // This will hold the character's HTML element
                direction: 'down', // Default direction
                name: name, // Store the character's name
                role: role // Store the character's role
            };
        }

        // Function to initialize characters (modified to add character based on ID)
        async function initializeCharacters() {
            try {
                const response = await fetch('http://localhost:3000/characters');
                const data = await response.json();

                if (data.length > 0) {
                    // Characters were fetched from the server
                    data.forEach(characterData => {
                        const initialRow = Math.floor(Math.random() * 30); // Random initial row
                        const initialCol = Math.floor(Math.random() * 50); // Random initial column
                        const hero = {
                            ...characterData,
                            position: { row: initialRow, col: initialCol },
                            element: null // This will hold the character's HTML element
                        };
                        characters.push(hero);
                    });
                } else {
                    // No characters found, generate them randomly
                    for (let i = 0; i < numOfHeroes; i++) {
                        const initialRow = Math.floor(Math.random() * 30); // Random initial row
                        const initialCol = Math.floor(Math.random() * 50); // Random initial column
                        const hero = createCharacter(Math.floor(Math.random() * 6) + 1, initialRow, initialCol);
                        characters.push(hero);
                    }
                    // Save the generated characters to the server
                    await saveCharactersToServer(characters);
                }

                // Check if a characterId was sent from character_select.html
                const urlParams = new URLSearchParams(window.location.search);
                const characterId = urlParams.get('characterId');
                if (characterId) {
                    const heroType = parseInt(characterId); // Convert to integer
                    const initialRow = 0; // Set to row 0
                    const initialCol = 10; // Set to column 10
                    const playerCharacter = createCharacter(heroType, initialRow, initialCol, true); // Create "You" character
                    characters.push(playerCharacter); // Add to characters list
                }

                // Now render the characters on the map
                renderCharacters();
            } catch (error) {
                console.error('Error fetching characters:', error);
            }
        }

        // Function to save characters to the server
        async function saveCharactersToServer(charactersToSave) {
            try {
                await fetch('http://localhost:3000/characters', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(charactersToSave),
                });
            } catch (error) {
                console.error('Error saving characters:', error);
            }
        }

        // Function to render characters on the map
        function renderCharacters() {
            characters.forEach(hero => {
                // Create an image element for the character
                hero.element = document.createElement('img');
                hero.element.src = `hero${hero.type}/hero_down_1.png`; // Initial image (facing down)
                hero.element.classList.add('character');

                // Append the character to its initial position
                table.rows[hero.position.row].cells[hero.position.col].appendChild(hero.element);

                // Check if this character is the player character
                if (hero.name === "You") {
                    hero.element.classList.add('highlight'); // Add highlight class
                }

                // Add event listener to each character
                hero.element.addEventListener('click', async (event) => {
                    event.stopPropagation(); // Prevent the click from bubbling up to the body
                    const characterName = hero.name; // Get the character's name

                    // Request the chat history from the server
                    try {
                        const response = await fetch(`http://localhost:3000/chat/history`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ name: characterName }), // Send the character name to the server
                        });

                        if (!response.ok) throw new Error('Failed to fetch chat history');

                        const data = await response.json(); // Get the chat history from the response
                        const chatHistory = data.history; // Extract the history
                        // Show chat container and display the character's name and role
                        chatContainer.style.display = 'block'; // Show chat container
                        const chatHeader = document.getElementById('chatHeader');
                        chatHeader.innerHTML = `<strong>${hero.name}</strong>, ${hero.role}`; // Display name and role
                        
                        // Display the character's chat history
                        chatOutput.innerHTML = ''; // Clear previous chat output
                        const messages = chatHistory.split('\n'); // Assuming each message is separated by a newline
                        messages.forEach(msg => {
                            if (msg.trim()) { // Check if the message is not just whitespace
                                const [sender, text] = msg.split(': '); // Split by ": " to separate sender and message
                                const messageClass = sender === 'You' ? 'user-message' : 'character-message'; // Determine message class
                                chatOutput.innerHTML += `<div class="message ${messageClass}"><strong>${sender}:</strong> ${text}</div>`;
                                chatOutput.innerHTML += `<div class="separator"></div>`; // Add separator
                            }
                        });

                        // Scroll to the bottom of the chat output
                        chatOutput.scrollTop = chatOutput.scrollHeight; // Ensure the latest message is visible

                        // Set the active character in the chat container
                        chatContainer.setAttribute('data-active-character', characters.indexOf(hero)); // Set the active character index

                    } catch (error) {
                        console.error('Error fetching chat history:', error);
                        chatOutput.innerHTML = `<p><strong>Error:</strong> Unable to load chat history.</p>`;
                    }
                });
            });
        }

        // Call the function to initialize characters on page load
        initializeCharacters();

        // Chat functionality
        const chatOutput = document.getElementById('chatOutput');
        const chatInput = document.getElementById('chatInput');
        const sendChatButton = document.getElementById('sendChatButton');
        const closeChatButton = document.getElementById('closeChatButton');

        // Close chat functionality
        closeChatButton.addEventListener('click', () => {
            chatContainer.style.display = 'none'; // Hide chat container
        });

        // Function to send message
        async function sendMessage() {
            const activeCharacterIndex = chatContainer.getAttribute('data-active-character');
            const character = characters[activeCharacterIndex];
            const message = chatInput.value;

            if (!message) return; // Don't send empty messages

            // Clear input field
            chatInput.value = '';

            // Display user message with separator
            chatOutput.innerHTML += `<div class="message user-message"><strong>You:</strong> ${message}</div>`;
            chatOutput.innerHTML += `<div class="separator"></div>`; // Add separator

            // Send message to the server and get character response
            try {
                const response = await fetch('http://localhost:3000/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: message,
                        name: character.name,
                        characterRole: character.role
                    }),
                });
                if (!response.ok) throw new Error('Network response was not ok');
                const data = await response.json();

                // Display character's response using their name with separator
                chatOutput.innerHTML += `<div class="message character-message"><strong>${character.name}:</strong> ${data.response}</div>`;
                chatOutput.innerHTML += `<div class="separator"></div>`; // Add separator

                // Scroll to the bottom of the chat output
                chatOutput.scrollTop = chatOutput.scrollHeight; // Ensure the latest message is visible
            } catch (error) {
                console.error('Error:', error);
                chatOutput.innerHTML += `<p><strong>Error:</strong> Unable to send message.</p>`;
            }
        }

        // Send message on button click
        sendChatButton.addEventListener('click', sendMessage);

        // Send message on Enter key press
        chatInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                sendMessage();
            }
        });

        // Function to get a random adjacent position (up, down, left, right)
        function getRandomAdjacentPosition(character) {
            const directions = [
                { row: -1, col: 0, direction: 'up' }, // up
                { row: 1, col: 0, direction: 'down' }, // down
                { row: 0, col: -1, direction: 'left' }, // left
                { row: 0, col: 1, direction: 'right' }, // right
            ];

            let newPosition;
            let isValidMove = false;

            // Keep trying until a valid move is found
            while (!isValidMove) {
                const randomDirection = directions[Math.floor(Math.random() * directions.length)];
                const newRow = character.position.row + randomDirection.row;
                const newCol = character.position.col + randomDirection.col;

                // Check if new position is within bounds
                if (newRow >= 0 && newRow < 30 && newCol >= 0 && newCol < 50) {
                    // Check for obstacles
                    if (!isObstacle(newRow, newCol)) {
                        newPosition = { row: newRow, col: newCol, direction: randomDirection.direction };
                        isValidMove = true; // Valid move found
                    }
                }
            }
            return newPosition;
        }

        // Function to check if the position is occupied by an environmental element
        function isObstacle(row, col) {
            // Check for each environmental element and its occupied cells
            for (const element of environmentalElements) {
                const { element_name, position } = element;
                const occupiedCells = getOccupiedCells(element_name, position);

                for (const cell of occupiedCells) {
                    if (cell.row === row && cell.col === col) {
                        return true; // Obstacle found
                    }
                }
            }
            return false; // No obstacles
        }

        // Function to get occupied cells based on the element type
        function getOccupiedCells(element_name, position) {
            const cells = [];
            const { row, col } = position;

            if (element_name === 'house') {
                // house occupies a 3x2 area
                for (let r = row; r < row + 2; r++) {
                    for (let c = col; c < col + 3; c++) {
                        cells.push({ row: r, col: c });
                    }
                }
            } else {
                // Other elements occupy a 2x2 area
                for (let r = row; r < row + 2; r++) {
                    for (let c = col; c < col + 2; c++) {
                        cells.push({ row: r, col: c });
                    }
                }
            }
            return cells;
        }

        // Function to move all characters
        function moveCharacters() {
            if (!isMoving) return; // Exit if movement is stopped

            characters.forEach(character => {
                const newPosition = getRandomAdjacentPosition(character);
                const currentCell = table.rows[character.position.row].cells[character.position.col];
                const newCell = table.rows[newPosition.row].cells[newPosition.col];

                let moveCount = 0;
                let moving = false;

                if (moving) return;
                moving = true;

                let interval = setInterval(() => {
                    if (moveCount < 6) {
                        moveCount++;
                        const movementDistance = 5 * moveCount;

                        switch (newPosition.direction) {
                            case 'up':
                                character.element.src = `hero${character.type}/hero_up_${moveturn[moveCount]}.png`;
                                character.element.style.transform = `translateY(${-movementDistance}px)`;
                                break;
                            case 'down':
                                character.element.src = `hero${character.type}/hero_down_${moveturn[moveCount]}.png`;
                                character.element.style.transform = `translateY(${movementDistance}px)`;
                                break;
                            case 'left':
                                character.element.src = `hero${character.type}/hero_left_${moveturn[moveCount]}.png`;
                                character.element.style.transform = `translateX(${-movementDistance}px)`;
                                break;
                            case 'right':
                                character.element.src = `hero${character.type}/hero_right_${moveturn[moveCount]}.png`;
                                character.element.style.transform = `translateX(${movementDistance}px)`;
                                break;
                        }
                    } else {
                        clearInterval(interval);
                        currentCell.removeChild(character.element);
                        character.position = { row: newPosition.row, col: newPosition.col };
                        character.element.src = `hero${character.type}/hero_${newPosition.direction}_2.png`;
                        character.element.style.transform = `translateX(0) translateY(0)`;
                        newCell.appendChild(character.element);
                        moving = false;
                    }
                }, 250);
            });
        }
        
        moveCharacters(); 
        // Start the movement every 2 seconds
        setInterval(moveCharacters, 1780); // Move characters every 1780 milliseconds

        // Environmental element placement
        let selectedElement = null;

        // Select environmental element on click
        document.getElementById('treeIcon').addEventListener('click', () => {
            selectedElement = 'tree';
            tableContainer.style.cursor = 'url(map_add_1.png), auto'; // Change cursor to tree icon
        });

        document.getElementById('lakeIcon').addEventListener('click', () => {
            selectedElement = 'lake';
            tableContainer.style.cursor = 'url(map_add_2.png), auto'; // Change cursor to lake icon
        });

        // Select house environmental element
        document.getElementById('houseIcon').addEventListener('click', () => {
            selectedElement = 'house';
            tableContainer.style.cursor = 'url(map_add_3.png), auto'; // Change cursor to house icon
        });

        // Place environmental element on map click
        tableContainer.addEventListener('click', async (event) => {
            if (selectedElement) {
                const rect = table.getBoundingClientRect();
                const x = event.clientX - rect.left; // X position relative to the table
                const y = event.clientY - rect.top; // Y position relative to the table
                const row = Math.floor(y / 30); // Assuming each cell is 30px high
                const col = Math.floor(x / 30); // Assuming each cell is 30px wide

                // Check if the selected position and the next row and column are valid
                let elementImg;
                if (selectedElement === 'house') {
                    // Ensure it fits within bounds for 3 wide and 2 tall
                    if (row >= 0 && row < 29 && col >= 0 && col < 48 && !isObstacle(row, col)) {
                        elementImg = document.createElement('img');
                        elementImg.src = 'map_add_3.png'; // Use the house image
                        elementImg.classList.add('large-element'); // Add class for styling
                        elementImg.style.left = `${col * 30}px`; // Position based on cell size
                        elementImg.style.top = `${row * 30}px`; // Position based on cell size

                        // Append the image to the table container
                        tableContainer.appendChild(elementImg);
                        environmentalElements.push({ element_name: 'house', position: { row, col } }); // Track the element
                        // Save to server
                        await saveElementToServer(selectedElement, row, col);
                    }
                } else {
                    // For tree and lake, maintain the 2x2 size
                    if (row >= 0 && row < 29 && col >= 0 && col < 49 && !isObstacle(row, col)) {
                        elementImg = document.createElement('img');
                        elementImg.src = selectedElement === 'tree' ? 'map_add_1.png' : 'map_add_2.png'; // Use the correct image
                        elementImg.classList.add('small-element'); // Add class for 2x2 styling
                        elementImg.style.left = `${col * 30}px`; // Position based on cell size
                        elementImg.style.top = `${row * 30}px`; // Position based on cell size

                        // Append the image to the table container
                        tableContainer.appendChild(elementImg);
                        environmentalElements.push({ element_name: selectedElement, position: { row, col } }); // Track the element
                        // Save to server
                        await saveElementToServer(selectedElement, row, col);
                    }
                }

                // Reset the selected element so it can't be placed again until re-selected
                selectedElement = null;
                tableContainer.style.cursor = 'grab'; // Reset cursor back to grab
            }
        });

        // Function to save environmental element to the server
        async function saveElementToServer(elementName, row, col) {
            try {
                await fetch('http://localhost:3000/city', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ element_name: elementName, row: row, col: col }),
                });
            } catch (error) {
                console.error('Error saving environmental element:', error);
            }
        }

        // Function to load environmental elements from the server
        async function loadEnvironmentalElements() {
            try {
                const response = await fetch('http://localhost:3000/city');
                const elements = await response.json();

                elements.forEach(element => {
                    const { element_name, row, col } = element;
                    let elementImg;

                    if (element_name === 'house') {
                        elementImg = document.createElement('img');
                        elementImg.src = 'map_add_3.png';
                        elementImg.classList.add('large-element');
                        elementImg.style.left = `${col * 30}px`;
                        elementImg.style.top = `${row * 30}px`;
                        tableContainer.appendChild(elementImg);
                        environmentalElements.push({ element_name: 'house', position: { row, col } }); // Track the element
                    } else {
                        elementImg = document.createElement('img');
                        elementImg.src = element_name === 'tree' ? 'map_add_1.png' : 'map_add_2.png';
                        elementImg.classList.add('small-element');
                        elementImg.style.left = `${col * 30}px`;
                        elementImg.style.top = `${row * 30}px`;
                        tableContainer.appendChild(elementImg);
                        environmentalElements.push({ element_name: element_name, position: { row, col } }); // Track the element
                    }
                });
            } catch (error) {
                console.error('Error loading environmental elements:', error);
            }
        }

        // Load environmental elements on page load
        loadEnvironmentalElements();

        // Reset cursor when not placing elements
        tableContainer.addEventListener('mouseleave', () => {
            tableContainer.style.cursor = 'grab'; // Reset cursor back to grab
        });

        function alignCharacters() {
            const centerRow = Math.floor(table.rows.length / 2);
            const centerColStart = Math.floor((table.rows[0].cells.length - characters.length) / 2);

            characters.forEach((character, index) => {
                const targetCol = centerColStart + index;

                const currentCell = table.rows[character.position.row].cells[character.position.col];
                const newCell = table.rows[centerRow].cells[targetCol];

                character.position = { row: centerRow, col: targetCol };

                currentCell.removeChild(character.element);
                newCell.appendChild(character.element);

                character.element.src = `hero${character.type}/hero_down_2.png`;
            });
        }

        function hideEnvironmentalElements() {
            const largeElements = document.querySelectorAll('.large-element'); // Select all large elements
            const smallElements = document.querySelectorAll('.small-element'); // Select all small elements

            // Hide large elements
            largeElements.forEach(element => {
                element.style.display = 'none'; // Hide the large element
            });

            // Hide small elements
            smallElements.forEach(element => {
                element.style.display = 'none'; // Hide the small element
            });
        }

        // Function to show large and small environmental elements
        function showEnvironmentalElements() {
            const largeElements = document.querySelectorAll('.large-element'); // Select all large elements
            const smallElements = document.querySelectorAll('.small-element'); // Select all small elements

            // Show large elements
            largeElements.forEach(element => {
                element.style.display = ''; // Reset to original display
            });

            // Show small elements
            smallElements.forEach(element => {
                element.style.display = ''; // Reset to original display
            });
        }

        let isInEvent = false; // Track whether the user is currently in the event

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function sendEventMessage(message) {
            // Select a random character from the characters array
            const randomIndex = Math.floor(Math.random() * characters.length);
            const selectedCharacter = characters[randomIndex];

            // Prepare the data to send to the server
            const dataToSend = {
                message: message,
                characterName: selectedCharacter.name,
                characterRole: selectedCharacter.role
            };

            try {
                const response = await fetch('http://localhost:3000/event', {
                    method: 'POST', // Send a POST request
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(dataToSend) // Send the character name, role, and message as JSON
                });

                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }

                const data = await response.json(); // Assuming the server responds with JSON
                const chatOutput = document.getElementById('chatOutput');

                // Display character's response using their name with separator
                chatOutput.innerHTML += `<div class="message character-message"><strong>${selectedCharacter.name}:</strong> ${data.response}</div>`;
                chatOutput.innerHTML += `<div class="separator"></div>`; // Add separator

                // Scroll to the bottom of the chat output
                chatOutput.scrollTop = chatOutput.scrollHeight; // Ensure the latest message is visible
            } catch (error) {
                console.error('Error sending event message:', error);
            }
        }


        document.getElementById('joinEventButton').addEventListener('click', () => {
            const joinEventButton = document.getElementById('joinEventButton');
            const cells = document.querySelectorAll('table td'); // Select all table cells

            if (!isInEvent) {
                // Open the chat box with the title "The Event"
                const chatContainer = document.getElementById('chatContainer');
                chatContainer.style.display = 'block'; // Show chat container
                const chatHeader = document.getElementById('chatHeader');
                chatHeader.innerHTML = `<strong>The Event</strong>`; // Set the header to "The Event"

                // Welcome message
                const welcomeMessage = "Hello town! Welcome to the grand event of the town, we, the town citizens have gathered around today to choose a topic about our great town and discuss it, the topic can be about your issues as a town member or just anything about the town in general! please choose a topic to discuss...";
                const chatOutput = document.getElementById('chatOutput');
                chatOutput.innerHTML += `<div>${welcomeMessage}</div>`; // Display the welcome message

                // Change button text to "Leave Event"
                joinEventButton.innerText = "Leave event";
                isInEvent = true; // Set event status to true
                // User is joining the event
                isMoving = false;
                hideEnvironmentalElements();
                cells.forEach(cell => {
                    cell.style.background = 'transparent'; // Set the background to transparent
                });

                // Disable dragging
                isDraggingEnabled = false;

                // Start countdown
                countdown = 60; // Reset countdown
                const timerDisplay = document.createElement('div'); // Create a timer display
                timerDisplay.id = 'timerDisplay';
                timerDisplay.style.position = 'absolute';
                timerDisplay.style.top = '50px'; // Position below the button
                timerDisplay.style.left = '10px'; // Align with the button
                timerDisplay.style.fontSize = '20px'; // Font size for the timer
                timerDisplay.style.color = '#2C4F6B'; // Timer color
                document.body.appendChild(timerDisplay); // Add timer to the document
                
                // Update timer every second
                timer = setInterval(() => {
                    timerDisplay.innerText = `Time remaining: ${countdown} seconds`;
                    alignCharacters();
                    countdown--;

                    // Send chat messages to the server while the event is running
                    const chatMessages = document.getElementById('chatOutput').innerHTML; // Get current chat messages
                    sendEventMessage(chatMessages); // Send messages to the server

                    if (countdown < 0) {
                        cells.forEach(cell => {
                            cell.style.background = ''; // Reset to default, or set a specific color/image
                        });
                        showEnvironmentalElements();
                        clearInterval(timer); // Clear the timer
                        timerDisplay.remove(); // Remove timer from the screen
                        isMoving = true; // Resume character movement

                        // Re-enable dragging
                        isDraggingEnabled = true;
                        isInEvent = false; // Reset event status
                        joinEventButton.innerText = "Join event"; // Reset button text
                        chatContainer.style.display = 'none'; // Hide chat container
                    }
                }, 1000); // Update every second

                // Adjust the view to center the characters above the bottom
                adjustViewToCenterCharacters();

            } else {
                // User is leaving the event
                clearInterval(timer); // Abort the countdown
                const timerDisplay = document.getElementById('timerDisplay');
                if (timerDisplay) {
                    timerDisplay.remove(); // Remove the timer display if it exists
                }

                // Reset the environment and state
                cells.forEach(cell => {
                    cell.style.background = ''; // Reset to default, or set a specific color/image
                });
                showEnvironmentalElements();
                isMoving = true; // Resume character movement
                isDraggingEnabled = true; // Re-enable dragging
                isInEvent = false; // Reset event status
                joinEventButton.innerText = "Join event"; // Reset button text

                // Hide the chat container
                const chatContainer = document.getElementById('chatContainer');
                chatContainer.style.display = 'none'; // Hide chat container
            }
        });

        // Function to adjust the view to center the characters above the bottom of the table container
        function adjustViewToCenterCharacters() {
            const centerRow = Math.floor(table.rows.length / 2);
            const centerColStart = Math.floor((table.rows[0].cells.length - characters.length) / 2);

            // Calculate the vertical position to scroll to, slightly above the bottom
            const offset = 370; // Adjust this value to position the characters above the bottom
            tableContainer.scrollTop = (centerRow * 30) - offset; // Assuming each cell is 30px high

            // Calculate horizontal position to center the characters
            const tableRect = tableContainer.getBoundingClientRect();
            const horizontalCenter = (centerColStart * 30) + (characters.length * 15) - (tableRect.width / 2);
            tableContainer.scrollLeft = horizontalCenter; // Center horizontally
        }

        // Scroll drag functionality
        let isDragging = false;
        let startX, startY;

        tableContainer.addEventListener('mousedown', (e) => {
            if (!isDraggingEnabled) return; // Exit if dragging is disabled
            isDragging = true;
            startX = e.pageX - tableContainer.offsetLeft;
            startY = e.pageY - tableContainer.offsetTop;
            tableContainer.style.cursor = 'grabbing'; // Change cursor to grabbing while dragging
            // Prevent image selection
            document.body.style.userSelect = 'none';
        });

        tableContainer.addEventListener('mousemove', (e) => {
            if (isDragging && isDraggingEnabled) { // Check if dragging is enabled
                const x = e.pageX - tableContainer.offsetLeft;
                const y = e.pageY - tableContainer.offsetTop;
                const walkX = (x - startX) * 2; // Adjust scroll speed horizontally
                const walkY = (y - startY) * 2; // Adjust scroll speed vertically
                tableContainer.scrollLeft -= walkX;
                tableContainer.scrollTop -= walkY;
                startX = x;
                startY = y;
            }
        });

        tableContainer.addEventListener('mouseup', () => {
            isDragging = false;
            tableContainer.style.cursor = 'grab'; // Reset cursor back to grab
            // Allow image selection again
            document.body.style.userSelect = '';
        });
    </script>

</body>
</html>